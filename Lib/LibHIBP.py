"""Contains the methods and classes to interact with iHIBPsim"""

import numpy as np
from version_suite import version
from LibMachine import machine
import LibPlotting as ssplt
import LibParameters as sspar
import LibMap as ssmap
import matplotlib.pyplot as plt
if machine == 'AUG':
    import LibDataAUG as ssdat

class orbits:
    """ Class to read and work orbits generated by the i-HIBPsim libraries. """
    def __init__(self, filename: str = None, load_all: bool = True):
        """
        Initialization of the orbit class. Loads the header.

        Pablo Oyola: pablo.oyola@ipp.mpg.de

        @param filename: Filename containing the orbit data. If provided,
                         this routine will read and store the header info.

        The header is data is stored at the end of the file:
            [...ORBIT DATA...]
            int32: List of steps recorded for each particle. (x nOrbits)
            int32: ID list stored in the file.               (x nOrbits)
            int32: Number of orbits stored                    = nOrbits
            int32: Number of elements stored per orbit step   = nCh
            int32: Orbit version number.a

        @param load_all: This flags sets the behaviour of orbits[1] to return
        either the whole data (if set to True) or only the spatial part (if set
        to False).
        """
        self.initialized = False
        if filename is not None:
            with open(file = filename, 'rb') as fid:
                fid.seek(-3*4, os.SEEK_END)
                self.nOrbits    = np.fromfile(fid, 'uint32', 1)
                self.nCh        = np.fromfile(fid, 'uint32', 1)
                self.version_orbits = np.fromfile(fid, 'uint32', 1)

                hdr_offset = - (3 * 4 + self.nOrbits * 4)
                fid.seek(hdr_offset, os.SEEK_END)
                self.stepsPerOrbit = np.fromfile(fid, 'uint32', self.nOrbits)
                self.idList = np.fromfile(fid, 'uint32', self.nOrbits)

                # Checking the file.
                if self.nOrbits == 0 :
                    print('No orbits stored in the file!')
                    return

                if self.nCh < 2:
                    print('The orbit file is stored in an invalid format!')
                    return

                # Data in the file seems valid. Let's prepare the offsets
                # so the data access is quicker and easier.
                self.offsets = np.cumsum(self.stepsPerOrbit, dtype=np.uint32)*4 
                self.offsets = np.vstack([0] self.offsets)

                # Rewind the file to the beginnig.
                fid.seek(0, 0)
                self.fid = fid
                self.initialized = True

                # Shortcut to access via __index__ overload.
                self.loadAll = True 
        return

    def loadOrbit(self, id: int, full_info: bool = False)
        """
        Loads from the file the orbits that are specified from the input.
        If some or all the 'id' provided do not exist, the corresponding
        is not loaded.

        Pablo Oyola: pablo.oyola@ipp.mpg.de

        WARNING: consider that the reading Fortran -> Python will transp-
        ose the matrix order.

        @param id: Vector of identifiers of the particle orbits to 
        load from the file.

        @param full_info: If false, only the trajectory will be loaded, if true,
        also the velocity, weight, charge and mass will be loaded.

        @return output: list with all the dictionaries with the orbit information:
            -# 'R', 'z', 'phi': for the position
            -# 'vR', 'vz', 'vt': for the velocity
            -# 'q', 'm': charge and mass
            -# 'logw': logarithmic weight
            -# 'time': time of each point
        @return id: Actual list of ID's read from the file. The dictionary output
        is stored in the same order as IDs are returned.
        """
        output = [] 
        if self.initialized and not self.chainLoadFlag:
            # Check where are the searched orbits:
            mask = np.in1d(self.idList, id, assume_unique=True, inverted=True)

            # With the mask created, we can take out all the orbits that
            # are not stored in the file, according to the header.
            id = id[mask]

            for iorbit in id:
                # Getting the ID index location:
                id_location = np.argmin(np.abs(self.idList-iorbit))
                offset = self.offsets[id_location]

                # Set the cursor at the appropriate point from the beginning.
                self.fid.seek(offset, 0)

                # Reading from the file.
                orbitData = np.fromfile(fid, np.float64, \ 
                                        self.stepsPerOrbit[id_location]*\
                                        self.nCh)

                orbitData = orbitData.reshape(self.nCh, \ 
                                              self.stepsPerOrbit[id_location])
                # Adding to the dictionary:
                output.append({})
                output[kk]['R'] = orbitData[:, 0]
                output[kk]['z'] = orbitData[:, 1]
                output[kk]['phi'] = orbitData[:, 2]
                output[kk]['m'] = orbitData[0, 6]
                output[kk]['q'] = orbitData[0, 7]
                output[kk]['time'] = orbitData[:, 9]

                if full_info:
                    output[kk]['vR'] = orbitData[:, 3]
                    output[kk]['vt'] = orbitData[:, 4]
                    output[kk]['vz'] = orbitData[:, 5]
                    output[kk]['logW'] = orbitData[:, 7]

                    # Computing the kinetic energy:
                    output[kk]['K'] = np.sqrt(orbitData[:, 3] ** 2 + \
                                              orbitData[:, 4] ** 2 + \
                                              orbitData[:, 5] ** 2)
                    
                    output[kk]['K'] *= output[kk]['m']

        return output, id

    def __index__(self, ii: int):
        """
        Loads from the file the orbits that are specified from the input.
        If some or all the 'id' provided do not exist, the corresponding
        is not loaded.
        This routine is just an overloaded operator that acts a wrapper
        for the 'loadOrbit'.

        Pablo Oyola: pablo.oyola@ipp.mpg.de

        @param id: Identifiers of the particle orbits to load from the
        file.

        @return (orbits, id): dictionary and ID list read from the file.
        \see{orbits::loadOrbit} for more info.
        """

        return self.loadOrbit(ii, full_info = self.loadAll)

    def switchLoadAll(self, flag_loadAll: bool = True):
        """
        This routine allows to access the internal variable for loading
        orbit data. This will change the behaviour of the __index__ 
        overloaded procedure to read only the spatial data or the full
        information, containing velocities and weighting evolution.

        @param flag_loadAll: if set to True, all the data will be loaded
        from the file, containing the spatial part (R, z, phi) as well as 
        velocities and weighting. Otherwise, only the spatial part will be
        loaded.
        """
        self.loadAll = flag_loadAll

    def initChainLoad(self):
        """
        The data in the orbit file can be accessed using a serial reading
        approach: one orbit after the other. This starts the appropriate
        flag in the class and allows the fast serial reading.
        """
        if self.initialized:
            self.chainLoadFlag = True
            self.nxtOrbit      = 0

            # Rewind the file to the origin.
            self.fid.seek(0, 0)
    
        return

    def getNextOrbit(self):
        """
        The data in the orbit file can be accessed using a serial reading
        approach: one orbit after the other. This starts the appropriate
        flag in the class and allows the fast serial reading.

        @return output: dictionary with the orbit information:
            -# 'R', 'z', 'phi': for the position
            -# 'vR', 'vz', 'vt': for the velocity
            -# 'q', 'm': charge and mass
            -# 'logw': logarithmic weight
            -# 'time': time of each point
        """
        if not self.initialized:
            raise Exception('Orbit object not initialized')

        if not self.chainLoadFlag:
            raise Warning('The orbit file \ is not opened for serial access')

        # Reached the end of the file.
        if self.nxtID > self.idList.size():
            raise Exception('End of the file orbit reached!')

        orbitData = np.fromfile(fid, np.float64, \ 
                                self.stepsPerOrbit[self.nxtOrbit]*\
                                self.nCh)

        orbitData = orbitData.reshape(self.nCh, \ 
                                      self.stepsPerOrbit[self.nxtOrbit])

        output = []
        # Adding to the dictionary:
        output['R'] = orbitData[:, 0]
        output['z'] = orbitData[:, 1]
        output['phi'] = orbitData[:, 2]
        output['m'] = orbitData[0, 6]
        output['q'] = orbitData[0, 7]
        output['time'] = orbitData[:, 9]

        if full_info:
            output['vR'] = orbitData[:, 3]
            output['vt'] = orbitData[:, 4]
            output['vz'] = orbitData[:, 5]
            output['logW'] = orbitData[:, 7]

            # Computing the kinetic energy:
            output['K'] = np.sqrt(orbitData[:, 3] ** 2 + \
                                        orbitData[:, 4] ** 2 + \
                                        orbitData[:, 5] ** 2)

        self.nxtOrbit += 1 # Next orbit.

        return output

    def endChainLoad(self):
        """
        This allows to arbitrarily search for orbits along the file.
        """
        if self.initialized:
            self.chainLoadFlag = False
            self.nxtOrbit = 0
        
        return

    def setChainPoint(self, pos: int = 0):
        """
        In the serial reading mode, this routine will change the position 
        that will be read in the following iteration.

        @param pos: Position index in the list of orbits to be read next. 
        By default, it comes to the beginning.

        @return pos_real: return the actual position that has been been set.
        """

        if self.initialized and self.chainLoadFlag:
            if pos < 0:
                actual_pos = 0
            else if pos > self.size():
                actual_pos = self.size()
            else:
                actual_pos = pos

            self.nxtOrbit = actual_pos

            return actual_pos
        
        return -1

    def size(self):
        """ Returns the number of orbits stored in the file.
        
        @return size: size of the ID list, i.e., number of particle orbits
        stored in the file.
        """
        return idList.size()

    def plot(id, view: str = '2D', ax_options: dict = {}, ax=None,
             line_options: dict = {}, shaded3d_options: dict = {},
             imin: int = 0, imax: int = None):
        """
        Plot the orbit

        Jose Rueda: jrrueda@us.es 
        ft.
        Pablo Oyola: pablo.oyola@ipp.mpg.de

        @param id: ID of the orbit. If we are in the serial reading, it will be
        ignored, and the next orbit will be loaded instead.
        @param view: '2D' to plot, (R,z), (x,y). '3D' to plot the 3D orbit
        @param ax_options: options for the function axis_beauty
        @param line_options: options for the line plot (markers, colors and so on)
        @param ax: axes where to plot, if none, new ones will be created. Note,
        if the '2D' mode is used, ax should be a list of axes, the first one for
        the Rz projection
        @param shaded3d_options: dictionary with the options for the plotting of
        the 3d vessel
        """

        if not self.initialized:
            raise Exception('The orbit object has not been initialized.')
        # --- Reading the orbits.
        if self.chainLoadFlag:
            orbit = self.getNextOrbit()
        else:
            orbit, id = self.loadOrbit(id)

        # --- Initialise the plotting parameters
        ax_options['ratio'] = 'equal'
        # The ratio must be always equal, otherwise is terrorism
        if 'fontsize' not in ax_options:
            ax_options['fontsize'] = 16
        if 'grid' not in ax_options:
            ax_options['grid'] = 'both'
        if 'linewidth' not in line_options:
            line_options['linewidth'] = 2
        # --- Get cartesian coordinates:
        x = orbit['R'] * np.cos(orbit['phi'])
        y = orbit['R'] * np.sin(orbit['phi'])
        if imax is None:
            imax = len(x) - 1
        if imax > len(x):
            imax = len(x) - 1
        if view == '2D':
            # Open the figure
            if ax is None:
                fig, ax = plt.subplots(1, 2)
            # Plot the Rz, projection
            ax[0].plot(orbit['R'][imin:imax], orbit['z'][imin:imax],
                    label='ID: ' + str(orbit['ID']), **line_options)
            ax_options['xlabel'] = 'R [m]'
            ax_options['ylabel'] = 'z [m]'
            ssplt.plot_vessel(ax=ax[0])
            ax[0] = ssplt.axis_beauty(ax[0], ax_options)
            # Plot the xy projection

            ax[1].plot(x[imin:imax], y[imin:imax],
                    label='ID: ' + str(orbit['ID']), **line_options)
            # plot the initial and final points in a different color
            ax[1].plot(x[imax], y[imax], 'o', color='r')
            ax[1].plot(x[imin], y[imin], 'o', color='g')
            ax_options['xlabel'] = 'x [m]'
            ax_options['ylabel'] = 'y [m]'
            ssplt.plot_vessel(projection='toroidal', ax=ax[1])
            ax[1] = ssplt.axis_beauty(ax[1], ax_options)
            plt.tight_layout()
        else:
            # Open the figure
            if ax is None:
                fig = plt.figure()
                ax = fig.add_subplot(111, projection='3d')
            # Plot the orbit
            ax.plot(x[imin:imax], y[imin:imax],
                    orbit['z'][imin:imax], **line_options)
            ssplt.plot_vessel(ax=ax, projection='3D', params3d=shaded3d_options)
            ax_options['xlabel'] = 'x [m]'
            ax_options['ylabel'] = 'y [m]'
            ax_options['zlabel'] = 'z [m]'
            # ax = ssplt.axis_beauty(ax, ax_options)
        return ax

    """ 
    The following routines handle extra parameters that can be computed 
    from an input magnetic fields.
    Calculation of pitch-angle, toroidal canonical momentum, magnetic
    dipole momentum, ...
    
    A magnetic field input is here required.
    """

