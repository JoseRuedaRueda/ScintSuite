"""
i-HIBPsim -  Lib Strikes.

This library takes care of reading the strikes and their manipulation.
"""

import numpy as np
import matplotlib.cm as cm
import matplotlib.colors as colors
import matplotlib.pyplot as plt
import Lib.LibParameters as sspar
import Lib.LibPlotting as ssplt
import Lib.LibData as aug
from Lib.LibPaths import Path
from Lib.LibMachine import machine
import warnings


from Lib.LibData import get_rho
import Lib.SimulationCodes.iHIBPsim.hibp_utils as utils
try:
    import netCDF4 as nc4
except:
    warnings.warn('netCDF4 library not found. Install it to use iHIBPsim.')

if machine == 'AUG':
    import dd
import os
# from Lib.LibIO import getFileSize
from os import listdir
from warnings import warn

pa = Path()

# -----------------------------------------------------------------------------
# --- Index translation.
# -----------------------------------------------------------------------------
MARK_ID = 0
MARK_R  = 1
MARK_Z  = 2
MARK_PHI = 3
MARK_VR  = 4
MARK_VPHI = 5
MARK_VZ = 6
MARK_MASS = 7
MARK_Q = 8
MARK_WEIGHT = 9
MARK_TIME = 10
MARK_RHOPOL0 = 11
MARK_R0 = 12
MARK_Z0 = 13
MARK_X1 = 14
MARK_X2 = 15
MARK_X3 = 16
MARK_LAMBDA = 17
MARK_TPERP = 18
MARK_ANGLE = 19
MARK_INTENSITY = 20


# ----------------------------------------------------------------------------
# --- Other parameters.
# ----------------------------------------------------------------------------

scintillator_limits_X = aug.IHIBP_scintillator_X
scintillator_limits_Y = aug.IHIBP_scintillator_Y

AUG_STRIKELINE_DATABASE = pa.ihibpsim_strline_database

sigma2fwhm = 2.0*np.sqrt(2.0*np.log(2.0))
j2keV = 1.0/sspar.ec*1.0e-3 # Jules to keV conversion factor.

def getFileSize(fid):
    """
    given file handler (opened via the 'open' routine in Python), the total
    size of the file is obtained.

    Pablo Oyola - pablo.oyola@ipp.mpg.de

    @param fid: File handler.
    @return size: Length in bytes of the file.
    """

    # Gets the actual position in the file, so we can return there after
    # making the count.
    actualPos = fid.tell()

    # Going to the end of the file.
    fid.seek(0, sspar.SEEK_EOF)
    size = fid.tell()

    # Going back to the original point:
    fid.seek(actualPos, sspar.SEEK_BOF)

    return size

# -----------------------------------------------------------------------------
# --- Function to read the strike file.
# -----------------------------------------------------------------------------
def readStrikeFile(filename: str):
    """
    Read the strikes from a file as written by i-HIBPsim and stores it into
    a dictionary.

    Pablo Oyola - pablo.oyola@ipp.mpg.de

    @param filename: name of the file with the strike data.
    @return output: dictionary with the data parsed.
    """

    with open(filename) as fid:
        nstrikes = np.fromfile(fid, 'int32', 1)[0]
        nch      = np.fromfile(fid, 'int32', 1)[0]
        data     = np.fromfile(fid, 'float64', nch*nstrikes)

        data = np.reshape(data, (nstrikes, nch)).T

        output = {}
        output['nStrikes'] = nstrikes
        output['nCh'] = nch
        output['data'] = data
        output['ID'] = data[MARK_ID, :]
        output['R'] = data[MARK_R, :]
        output['z'] = data[MARK_Z, :]
        output['phi'] = data[MARK_PHI, :]
        output['vr'] = data[MARK_VR, :]
        output['vphi'] = data[MARK_VPHI, :]
        output['vz'] = data[MARK_VZ, :]
        output['mass'] = data[MARK_MASS, :]
        output['q'] = data[MARK_Q, :]
        output['w'] = np.exp(data[MARK_WEIGHT, :])
        output['time'] = data[MARK_TIME, :]
        if nch > 11 :
            output['rhopol0'] = data[MARK_RHOPOL0, :]
            output['R0'] = data[MARK_R0, :]
            output['z0'] = data[MARK_Z0, :]
            output['x1'] = data[MARK_X1, :]
            output['x2'] = -data[MARK_X2, :]
            output['x3'] = data[MARK_X3, :]
            output['lambda'] = data[MARK_LAMBDA, :]
            output['tperp'] = data[MARK_TPERP, :]
            output['angle'] = data[MARK_ANGLE, :]
            output['I'] = data[MARK_INTENSITY, :]

        return output

def readStrikeMapFile(filename: str, flip_y: bool = False, header: bool=True):
    """
    This routine reads the data stored in the file '.map' generated by
    i-HIBPsim and returns the strike map in a dictionary.

    Pablo Oyola - pablo.oyola@ipp.mpg.de

    @param filename: File name where the map is stored.
    @return mapsOut: lists with the strikemaps and the corresponding time
    stamp.
    """

    if flip_y:
        sign_y = -1.0
    else:
        sign_y = +1.0

    with open(filename, 'rb') as fid:
        # Number of points for the mapping.

        # Header size ( = 220 bytes)
        # Version: int*4 x3
        # - Beam Geometry.
        # Injection angles: float*8 x2 (in rad)
        # beamModel: int*4 x1
        # Beam energy and FWMH_E: float*8 x2 (J)
        # Beam divergency: float*8 x1 (in rad)
        # Species mass: float*8 x1 (in kg)
        # Beam current: float*8 x1 (in A)
        # Origin point (Cartesian): float*8 x3 (in m)
        # - Weighting of the strikeline.
        # Weighing mode: int*4 x1.
        # Beam attenuation flag: int*4 x1 (to be casted into boolean)
        # - EM model.
        # Electric field model: int*4 x1
        # Bcoils on: int*4 x1 (to be casted into boolean)
        # EQU experiment: char*3
        # EQU diagnostic: char*4
        # EQU edition: int*4 x1
        # EQU shotnumber: int*4 x1
        # Bcoils experiment: char*3
        # Bcoils diagnostic: char*4
        # Bcoils edition: int*4 x1
        # Bcoils shotnumber: int*4 x1
        # Profiles experiment: char*3
        # Profiles diagnostic: char*4
        # Profiles edition: int*4 x1
        # Profiles shotnumber: int*4 x1

        nPoints = np.fromfile(fid, 'int32', 1)
        if header:
            version = np.fromfile(fid, 'int32', 3)
            inj_angles  = np.fromfile(fid, 'float64', 2)*180.0/np.pi # to [ยบ]
            beamModel   = np.fromfile(fid, 'int32', 1)[0]
            map_method  = np.fromfile(fid, 'int32', 1)[0]
            Einj        = np.fromfile(fid, 'float64', 1)[0]*j2keV # in [keV]
            FWMH_E      = np.fromfile(fid, 'float64', 1)[0]*sigma2fwhm*j2keV
            divergency  = np.fromfile(fid, 'float64', 1)[0]*180.0/np.pi # to [ยบ]
            beammass    = np.fromfile(fid, 'float64', 1)[0]/sspar.amu2kg # AMU
            beamIntens  = np.fromfile(fid, 'float64', 1)[0]*1.0e3 # [mA]
            origin_inj  = np.fromfile(fid, 'float64', 3) # [m]
            strlin_mode = np.fromfile(fid, 'int32', 1)[0]
            elec_model  = np.fromfile(fid, 'int32', 1)[0]
            bcoils_flg  = np.fromfile(fid, 'int32', 1).astype(bool)[0]
            vacfield_flg= np.fromfile(fid, 'int32', 1).astype(bool)[0]
            expmagn_r   = np.fromfile(fid, 'byte',  4)
            diagmag_r   = np.fromfile(fid, 'byte',  3)
            ed_magn     = np.fromfile(fid, 'int32', 1)
            magn_shotn  = np.fromfile(fid, 'int32', 1)

            bcoilexp_r   = np.fromfile(fid, 'byte',  4)
            diagbcoil_r  = np.fromfile(fid, 'byte',  3)
            ed_bcoil     = np.fromfile(fid, 'int32', 1)
            bcoil_shotn  = np.fromfile(fid, 'int32', 1)

            exprof_r    = np.fromfile(fid, 'byte',  4)
            diagprf_r   = np.fromfile(fid, 'byte',  3)
            ed_prof     = np.fromfile(fid, 'int32', 1)
            prof_shotn  = np.fromfile(fid, 'int32', 1)


            # The strings have to be decoded before their use in python.
            tmp = b''.join(expmagn_r).strip()
            exp_magn = tmp.decode('utf8', errors='ignore').ljust(8)
            tmp = b''.join(diagmag_r).strip()
            diag_magn = tmp.decode('utf8', errors='ignore').ljust(3)

            tmp = b''.join(bcoilexp_r).strip()
            exp_bcoil = tmp.decode('utf8', errors='ignore').ljust(8)

            tmp = b''.join(diagbcoil_r).strip()
            diag_bcoil = tmp.decode('utf8', errors='ignore').ljust(3)

            tmp = b''.join(exprof_r).strip()
            exp_prof = tmp.decode('utf8', errors='ignore').ljust(8)

            tmp = b''.join(diagprf_r).strip()
            diag_prof = tmp.decode('utf8', errors='ignore').ljust(3)

            # --- Building the dictionary with the run data.
            rundata = { 'version': version,
                        'beam': { 'beta': inj_angles[0],
                                  'theta': inj_angles[1],
                                  'model': beamModel,
                                  'E': Einj,
                                  'FWMH_E': FWMH_E,
                                  'divergency': divergency,
                                  'mass': beammass,
                                  'origin': origin_inj,
                                  'intensity': beamIntens
                                },
                        'weighting': strlin_mode,
                        'map_method': map_method,
                        'fields': { 'electric': elec_model,
                                    'bcoils': bcoils_flg,
                                    'ripple_flag': vacfield_flg
                                  },
                        'magEQU': { 'pulseNumber': magn_shotn,
                                    'experiment': exp_magn,
                                    'diagnostic': diag_magn,
                                    'edition': ed_magn
                                  },
                        'profiles': { 'pulseNumber': prof_shotn,
                                    'experiment': exp_prof,
                                    'diagnostic': diag_prof,
                                    'edition': ed_prof
                                  },
                        'bcoils': { 'pulseNumber': bcoil_shotn,
                                    'experiment': exp_bcoil,
                                    'diagnostic': diag_bcoil,
                                    'edition': ed_bcoil
                                  },
                      }

        # --- Reading the maps.
        # Each map will occupy the following in the file:
        mapSize = 8 + 4 + nPoints*6*8

        # With filesize we can get the number of strikemaps recorded.
        fsize = getFileSize(fid)
        nMaps = fsize/mapSize
        nMaps = nMaps.astype(dtype='int32')[0]
        mapSize = mapSize[0]
        nPoints = nPoints[0]

        mapsOut = []
        for imap in range(nMaps):
            tmp = {}
            tmp['timestamp'] = np.fromfile(fid, 'float64', 1)
            tmp['nStrikes'] = np.fromfile(fid, 'int32', 1)
            tmp['map_s'] = np.fromfile(fid, 'float64', nPoints)
            tmp['x1'] = np.fromfile(fid, 'float64', nPoints)
            tmp['x2'] = sign_y*np.fromfile(fid, 'float64', nPoints)
            tmp['dx1'] = np.fromfile(fid, 'float64', nPoints)
            tmp['dx2'] = np.fromfile(fid, 'float64', nPoints)
            tmp['w'] = np.fromfile(fid, 'float64', nPoints)

            # Deleting the NaN channels.
            flags = np.logical_not(np.isnan(tmp['x1']))

            tmp['map_s'] = tmp['map_s'][flags]
            tmp['x1']     = tmp['x1'][flags]
            tmp['x2']     = tmp['x2'][flags]
            tmp['dx1']    = tmp['dx1'][flags]
            tmp['dx2']    = tmp['dx2'][flags]
            tmp['w']      = tmp['w'][flags]

            if header:
                tmp['rundata']= rundata

            mapsOut.append(tmp)
            del tmp

    return mapsOut

# -----------------------------------------------------------------------------
# --- Strikeline object.
# -----------------------------------------------------------------------------
class strikeLine:
    def __init__(self, filename: str, shotnumber: int = None,
                 diag: str = 'EQH', exp: str = 'AUGD', ed: int = 0,
                 scint: float = None):
        """
        Initializes the object strike line. This can contain several strike
        lines, as they are written altogether.

        Pablo Oyola - pablo.oyola@ipp.mpg.de

        @param filename: name of the file containing the strikelines.

        """

        self.maps = {}
        self.time = []
        self.shot = shotnumber
        self.equ_diag = diag
        self.equ_exp  = exp
        self.edition  = ed

        if filename is not None:
            self.Open(filename)

        if scint is None:
            self.Xlims = scintillator_limits_X
            self.Ylims = scintillator_limits_Y
        else:
            self.Xlims = scint[0:2]
            self.Ylims = scint[2:4]

        if shotnumber is not None:
            self.shotinfo = {}
            self.getEqu()

    @property
    def size(self):
        """
        Gets the number of maps stored in the class.

        Pablo Oyola - pablo.oyola@ipp.mpg.de
        """

        return len(self.maps)

    @property
    def shape(self):
        """
        Gets the shape of the stored maps:
            0 -> Number of maps
            1 -> Strikepoints per map.
        """

        return [self.size, len(self.maps[0]['x1'])]

    def Open(self, filename: str):
        """
        Reads from file the strikelines computed by i-HIBPsim and stores them
        into the class data.

        Pablo Oyola - pablo.oyola@ipp.mpg.de

        @param filename: name of the file with the strikelines.
        @param oldFlag: flag stating whether this is the new or older version
        of the strikemap file.

        """

        # Reading from the file the raw data.
        self.maps = readStrikeMapFile(filename, flip_y=True, header=True)

        # Storing the time coordinate
        self.time = np.zeros((len(self.maps)))
        for ii in range(len(self.maps)):
            self.time[ii] = self.maps[ii]['timestamp']

        ## We dump the header content into the class dictionary.
        for ikey in self.maps[0]['rundata']:
            self.__dict__[ikey] = self.maps[0]['rundata'][ikey]

        ## Translating the code numbers in the files into readable options:
        if self.weighting == 0:
            self.weight_name = 'no-weighting'
        elif self.weighting == 1:
            self.weight_name = 'density'
        elif self.weighting == 2:
            self.weight_name = 'ion current'

        if self.map_method == 0:
            self.map_name = 'Rmajor (1D)'
        elif self.map_method == 1:
            self.map_name = 'rhopol (1D)'
        elif self.map_method == 2:
            self.map_name = 'R, z (2D)'

    def plotStrikeLine(self, timeStamp: float = None, ax=None,
                       ax_options: dict = {}, line_options: dict = {},
                       legendText: str = None):
        """
        With an input list of maps for a given shot, this routine will plot the
        strikemap in the given axis.

        Pablo Oyola - pablo.oyola@ipp.mpg.de

        @param timeStamp: time to plot the strike line. The nearest strike
        line will be used. If None, all the strike maps are plotted.
        @param ax: axis handler to plot the strikeline. If None, new axis
        will be created.
        @param ax_options: dictionary with inputs for axis set-up.
        @param line_options: extra options to plot 1D lines.
        @param legendText: text to use as legend. If None, the time stamp will
        be used to label the strikelines.
        @param legend_on: sets or on/off the legend.
        @param plot_weigth: plots the weight along the strike line.
        """

        if timeStamp is None:
            imap = 0
        else:
            imap = np.searchsorted(self.time.flatten(), timeStamp)
        # --- Initialise the plotting parameters
        ax_options['ratio'] = 'equal'
        # The ratio must be always equal
        if 'fontsize' not in ax_options:
            ax_options['fontsize'] = 16
        if 'grid' not in ax_options:
            ax_options['grid'] = 'both'
        if 'linewidth' not in line_options:
            line_options['linewidth'] = 2

        if ax is None:
            fig, ax = plt.subplots(1)

        legendText = 't = ' + str(self.maps[imap]['timestamp'][0]) + ' [s]'
        im = ax.plot(self.maps[imap]['x1']*100, self.maps[imap]['x2']*100,
                     label=legendText, **line_options)

        ax_options['ratio'] = 'equal'
        ax_options['xlabel'] = 'X [cm]'
        ax_options['ylabel'] = 'Y [cm]'
        ax = ssplt.axis_beauty(ax, ax_options)
        ax.set_xlim(self.Xlims)
        ax.set_ylim(self.Ylims)

        return im


    def plotStrikeMap(self, timeStamp: float = None, ax=None,
                      ax_options: dict = {}, line_options: dict = {},
                      legendText: str = None, legend_on: bool = False,
                      plot_weight: bool = True):
        """
        With an input list of maps for a given shot, this routine will plot the
        strikemap in the given axis.

        Pablo Oyola - pablo.oyola@ipp.mpg.de

        @param timeStamp: time to plot the strike line. The nearest strike
        line will be used. If None, all the strike maps are plotted.
        @param ax: axis handler to plot the strikeline. If None, new axis
        will be created.
        @param ax_options: dictionary with inputs for axis set-up.
        @param line_options: extra options to plot 1D lines.
        @param legendText: text to use as legend. If None, the time stamp will
        be used to label the strikelines.
        @param legend_on: sets or on/off the legend.
        @param plot_weigth: plots the weight along the strike line.
        """

        if timeStamp is None:
            plot_all = True
        else:
            plot_all = False
            imap = np.abs(self.time.flatten() - timeStamp).argmin()

        # --- Initialise the plotting parameters
        ax_options['ratio'] = 'equal'
        # The ratio must be always equal
        if 'fontsize' not in ax_options:
            ax_options['fontsize'] = 16
        if 'grid' not in ax_options:
            ax_options['grid'] = 'both'
        if 'linewidth' not in line_options:
            line_options['linewidth'] = 2

        legendText_initial = legendText
        axis_was_none = False
        if ax is None:
            if plot_weight:
                fig, ax = plt.subplots(1, 2)
            else:
                fig, ax = plt.subplots()
            axis_was_none = True

        if plot_all:
            for ii in range(len(self.maps)):
                if legendText_initial is None:
                    legendText = 't = %.3f [s]'%self.maps[ii]['timestamp'][0]
                else:
                    legendText = 't = %.3f [s]'%self.maps[ii]['timestamp'][0]+\
                                 legendText_initial
                if plot_weight:
                    ax[0].plot(self.maps[ii]['x1']*100,
                               self.maps[ii]['x2']*100,
                               label=legendText, **line_options)

                    ds = np.diff(self.maps[ii]['map_s']).mean()
                    if self.weighting == 0:
                        w = self.maps[ii]['w']/ds
                        wylabel = 'Marker density (-)'
                    elif self.weighting == 1:
                        w = self.maps[ii]['w']/ds
                        wylabel = 'Ion density ($m^{-3}$)'
                    elif self.weighting == 2:
                        w = self.maps[ii]['w']/ds/sspar.ec
                        wylabel = 'Ion current ($ion\\cdot m^{-2}\\cdot s$)'

                    ax[1].plot(self.maps[ii]['map_s'],w,
                               label=legendText, **line_options)
                else:
                    ax.plot(self.maps[ii]['x1']*100,
                            self.maps[ii]['x2']*100,
                            label=legendText, **line_options)

        else:
            if legendText is None:
                legendText = 't = %.3f [s]'%self.maps[imap]['timestamp'][0]

            if plot_weight:
                ax[0].plot(self.maps[imap]['x1']*100,
                           self.maps[imap]['x2']*100,
                           label=legendText, **line_options)
                ds = np.diff(self.maps[imap]['map_s']).mean()
                if self.weighting == 0:
                    w = self.maps[imap]['w']/ds
                    wylabel = 'Marker density (-)'
                elif self.weighting == 1:
                    w = self.maps[imap]['w']/ds
                    wylabel = 'Ion density ($m^{-3}$)'
                elif self.weighting == 2:
                    w = self.maps[imap]['w']/ds/sspar.ec
                    wylabel = 'Ion current ($ion\\cdot m^{-2}\\cdot s$)'

                ax[1].plot(self.maps[imap]['map_s'], w,
                           label=legendText, **line_options)
            else:
                ax.plot(self.maps[imap]['x1']*100,
                        self.maps[imap]['x2']*100,
                        label=legendText, **line_options)

        if axis_was_none:
            ax_options['ratio'] = 'equal'
            ax_options['xlabel'] = 'X [cm]'
            ax_options['ylabel'] = 'Y [cm]'

            if plot_weight:
                ax[0] = ssplt.axis_beauty(ax[0], ax_options)
                ax[0].set_xlim(self.Xlims)
                ax[0].set_ylim(self.Ylims)


                ax_options['ratio'] = 'auto'
                if self.maps[0]['rundata']['map_method'] == 0:
                    ax_options['xlabel'] = '$\\rho_{pol}$ [-]'
                elif self.maps[0]['rundata']['map_method'] == 1:
                    ax_options['xlabel'] = 'Major radius R [m]'
                else:
                    raise Exception('Mode=3 not implemented')

                ax_options['ylabel'] = wylabel
                ax[1] = ssplt.axis_beauty(ax[1], ax_options)
                ax[1].yaxis.set_label_position('right')
                ax[1].yaxis.tick_right()
            else:
                ax = ssplt.axis_beauty(ax, ax_options)
                ax.set_xlim(self.Xlims)
                ax.set_ylim(self.Ylims)

        if legend_on:
            if plot_weight:
                ax[0].legend()
            else:
                ax.legend()

        plt.tight_layout()

        return ax

    def getEqu(self):
        """
        This routine will get from the AUG database the most important
        parameters that may affect the strikeline position. By default, all
        the parameters are taken.
        By default, Hmode flag, flat_top flag, Bcoils flag, ...

        Pablo Oyola - pablo.oyola@ipp.mpg.de


        """
        rhop4store = [0.0, 0.50, 0.80, 0.90, 0.95, 1.00]
        rhopNames  = ['0', '50', '80', '90', '95', '100']

        # Check if we have a shotnumber stored.
        if self.shot is None:
            raise Exception('No shotfile has been assigned to the object!')

        # Getting the SSQ data from the stored shotfile.
        ssq = aug.get_shot_basics(shotnumber=self.shot, diag=self.equ_diag,
                                  exp=self.equ_exp, edition=self.edition)

        # Getting the indices in the EQU timebase.
        tindx = np.zeros((len(self.time),), dtype = int)
        tindx_ip = np.zeros((len(self.time),), dtype = int)
        tindx_bt = np.zeros((len(self.time),), dtype = int)
        for ii in range(len(tindx)):
            tindx[ii] = np.abs(ssq['time']-self.time[ii]).argmin()
            tindx_ip[ii] = np.abs(ssq['iptime']-self.time[ii]).argmin()
            tindx_bt[ii] = np.abs(ssq['bttime']-self.time[ii]).argmin()
        try:
            self.shotinfo['q95'] = - ssq['q95'][tindx]
            self.shotinfo['q0']  = - ssq['q0'][tindx]
            self.shotinfo['Rgeom'] = ssq['Rgeo'][tindx]
            self.shotinfo['Raxis'] = ssq['Rmag'][tindx]
            self.shotinfo['Raus'] = ssq['Raus'][tindx]
            self.shotinfo['beta_pol'] = ssq['betpol'][tindx]
            self.shotinfo['H1'] = ssq['lenH-1'][tindx]
            self.shotinfo['H5'] = ssq['lenH-5'][tindx]
            self.shotinfo['elongation'] = ssq['k'][tindx]
            self.shotinfo['ip'] = ssq['ip'][tindx_ip]
            self.shotinfo['bt0'] = ssq['bt0'][tindx_bt]
        except:
            print('The shotinfo could not be fully read!')

        # --- Temperature and density data.
        try:
            print(self.shot)
            sf_ida = dd.shotfile(pulseNumber=self.shot, diagnostic='IDA',
                                 experiment='AUGD', edition=0)
        except:
            warn('The IDA profile cannot be loaded for #%05d'%self.shot)
            return

        Te = sf_ida(name='Te')
        ne = sf_ida(name='ne')
        tindx_ne = np.zeros((len(self.time),), dtype = int)
        tindx_te = np.zeros((len(self.time),), dtype = int)
        for ii in range(len(tindx)):
            tindx_ne[ii] = np.abs(ne.time.flatten() - self.time[ii]).argmin()
            tindx_te[ii] = np.abs(Te.time.flatten() - self.time[ii]).argmin()

        rhop = sf_ida(name='rhop').data[0, :]
        for ii in range(len(rhop4store)):
            rhop_indx = np.abs(rhop - rhop4store[ii]).argmin()

            name = 'ne'+rhopNames[ii]
            self.shotinfo[name] = ne.data[tindx_ne, rhop_indx]

            name = 'Te'+rhopNames[ii]
            self.shotinfo[name] = ne.data[tindx_ne, rhop_indx]

        sf_ida.close()


# -----------------------------------------------------------------------------
# --- Strikes object. Contains the striking points.
# -----------------------------------------------------------------------------
class strikes:
    def Open(self, filename: str, compute2nd: bool = True,
             strikemap: strikeLine=None):
        """
        Opens and overwrite into the class data the strike data found in the
        strike file.

        Pablo Oyola - pablo.oyola@ipp.mpg.de

        @param filename: name of the file with the strike data.
        @param compute2nd: compute derivate data, such as energy...
        @param strikemap: strikemap dictionary.
        """

        # Reading from the file.
        self.data = readStrikeFile(filename=filename)
        if not bool(self.data):
            raise Exception('Error while reading the file. Empty file')

        # Compute some derive information, such as energy, speed, the particle
        # flux.
        if compute2nd:
            self.data['v'] = np.sqrt(self.data['vr']**2 +
                                     self.data['vz']**2 +
                                     self.data['vphi']**2)
            self.data['K'] = 0.5*sspar.amu2kg*self.data['mass'] *\
                                              self.data['v']**2
            self.data['flux'] = self.data['w']*self.data['v'] # ion/s

        if strikemap is not None:
            self.map = strikemap
            self.mapSet = True
        else:
            self.map = None
            self.mapSet = False

    def __init__(self, filename: str, compute2nd: bool = True,
                 scint: float = None, strikemap: strikeLine = None):

        """
        Constructor of the strikes class.

        Pablo Oyola - pablo.oyola@ipp.mpg.de

        @param filename: name of the file with the strike data.
        @param compute2nd: compute derivate data, such as energy...
        @param scint: Scintillator limits. If None, the limits are taken
        as the standard ones.
        """

        if scint is None:
            scint = np.append(scintillator_limits_X,
                              scintillator_limits_Y)

        if len(scint) != 4:
            raise Exception('Incompatible shape for the scintillator input.')

        self.data = dict()
        if filename is not None:
            self.Open(filename=filename, compute2nd=compute2nd,
                      strikemap=strikemap)

        self.Xlims = scint[0:2]
        self.Ylims = scint[2:4]

    def plotScintillator(self, dx: float = 0.1, dy: float = 0.1, ax=None,
                         cmap=cm.plasma, kindplot: str = 'flux',
                         norm=None, ax_options: dict = {}, levels=100,
                         plot_strikemap: bool = False, min_cb: float = None,
                         max_cb: float = None):

        """
        Plot the scintillator image to the provided axis. If None are provided,
        new ones are created.

        Pablo Oyola - pablo.oyola@ipp.mpg.de

        @param dx: bin size in the Y-direction [cm]. Default to 100 um
        @param dy: bin size in the Y-direction [cm]. Default to 100 um
        @param ax: Axis to plot the scintillator image.
        @param cmap: Colormap to plot. By default, set to plasma.
        @param kindplot: type of plot to make: flux, intensity, density.
        @param norm: kind of norm for the colorbar. Linear if None is provided
        @param ax_options: dictionary with extract axis options.
        @param levels: levels for the contourf plot.

        @return ax: axis with the scintillator image.
        """

        # Checking the input axis. Creating one if None is provided.
        axis_was_none = False
        if ax is None:
            axis_was_none = True
            fig, ax = plt.subplots()

        # Checking the configuration of the axis.
        ax_option = {
            'ratio': 'equal',
            'fontsize': 16,
            'xlabel': 'X [cm]',
            'ylabel': 'Y [cm]'
        }
        ax_option.update(ax_options)

        # Scintillator size
        sizeX = self.Xlims[1]-self.Xlims[0]
        sizeY = self.Ylims[1]-self.Ylims[0]

        # Compute the number of points for the histogram.
        Nx = np.asarray(np.ceil(sizeX/dx), dtype=int)
        Ny = np.asarray(np.ceil(sizeY/dy), dtype=int)

        # Updating the bin sizes.
        dx = sizeX/Nx
        dy = sizeY/Ny

        # computing the histograms.
        if kindplot == 'flux':
            h, xe, ye, = np.histogram2d(self.data['x1']*100.0,
                                        self.data['x2']*100.0,
                                        weights=self.data['flux'],
                                        bins=(Nx, Ny),
                                        range=(self.Xlims, self.Ylims))

            h *= (dx*dy)
            clabel = 'Ion flux [ion/s]'

        elif kindplot == 'intensity':
            h, xe, ye, = np.histogram2d(self.data['x1']*100.0,
                                        self.data['x2']*100.0,
                                        weights=self.data['intensity']*1e6,
                                        bins=(Nx, Ny),
                                        range=(self.Xlims, self.Ylims))

            h *= (dx*dy)
            clabel = 'Ion current [$\\mu$A]'

        elif kindplot == 'weight':
            h, xe, ye, = np.histogram2d(self.data['x1']*100.0,
                                        self.data['x2']*100.0,
                                        weights=self.data['weight'],
                                        bins=(Nx, Ny),
                                        range=(self.Xlims, self.Ylims))

            clabel = 'Ion density [$m^{-3}$]'
        else:
            h, xe, ye, = np.histogram2d(self.data['x1']*100.0,
                                        self.data['x2']*100.0,
                                        weights=np.ones(self.data['x1'].shape),
                                        bins=(Nx, Ny),
                                        range=(self.Xlims, self.Ylims))

            clabel = 'Non-weighted [-]'

        xcenter = (xe[:-1] + xe[1:]) / 2.0
        ycenter = (ye[:-1] + ye[1:]) / 2.0

        # Setting up the options.
        cont_opts = {'cmap': cmap}

        if norm == 'log':
            cont_opts['norm'] = colors.LogNorm()
        elif norm == 'sqrt':
            cont_opts['norm'] = colors.PowerNorm(gamma=0.5)

        if (min_cb is not None) and (min_cb is not None):
            cont_opts['vmin'] = min_cb
            cont_opts['vmax'] = max_cb

        im = ax.pcolormesh(xcenter, ycenter, h.T, **cont_opts)

        # --- Plotting the strikemap:
        if self.mapSet and plot_strikemap:
            rhopolplot = np.linspace(start=self.map.maps[0]['map_s'].min(),
                                     stop=self.map.maps[0]['map_s'].max(),
                                     num=10)

            drhopol = rhopolplot[1] - rhopolplot[0]

            rhopolplot_vmin = rhopolplot.min() - drhopol/2
            rhopolplot_vmax = rhopolplot.max() + drhopol/2

            x1_plot = np.zeros(len(rhopolplot))
            x2_plot = np.zeros(len(rhopolplot))
            w_plot = np.zeros(len(rhopolplot))
            for ii in range(len(x1_plot)):
                irho = np.abs(self.map.maps[0]['map_s']-rhopolplot[ii]).argmin()
                x1_plot[ii] = self.map.maps[0]['x1'][irho]
                x2_plot[ii] = self.map.maps[0]['x2'][irho]
                w_plot[ii] = self.map.maps[0]['w'][irho]

                ax.plot(x1_plot[ii]*100, x2_plot[ii]*100, 'o',
                        markersize=5., label='%.2f'%rhopolplot[ii],
                        zorder=25)

            # # Generating the discrete colormap.
            # cmap2 = cm.get_cmap('tab10', len(rhopolplot))
            # im2 = ax.scatter(x=x1_plot*100.0, y=x2_plot*100.0,
            #                  c=rhopolplot, s=20.0,
            #                  cmap=cmap2,
            #                  vmin=rhopolplot_vmin,
            #                  vmax=rhopolplot_vmax,
            #                  zorder=5)

        if axis_was_none:
            ax.set_xlim(self.Xlims)
            ax.set_ylim(self.Ylims)
            ax = ssplt.axis_beauty(ax=ax, param_dict=ax_option)

            cbar = plt.colorbar(im, ax=ax)
            cbar.ax.get_yaxis().labelpad = 15
            cbar.ax.set_ylabel(clabel, rotation=270)

            # if self.mapSet and plot_strikemap:
            #     cbar2 = plt.colorbar(im2, ax=ax,
            #                          ticks = rhopolplot)
            #     cbar2.ax.get_xaxis().labelpad = 15
            #     cbar2.ax.set_xlabel('$\\rho_{pol}$')

            plt.tight_layout()

        return ax, {'x': xcenter, 'y': ycenter, 'W': h}



# -----------------------------------------------------------------------------
# --- Strikeline database object.
# -----------------------------------------------------------------------------
class strikeline_db:
    """
    This class manages the strike line database for the shots for the
    operation days. All the strike lines here should come from evaluation
    from the equilibrium already stored into the database of AUG.

    Pablo Oyola - pablo.oyola@ipp.mpg.de
    """

    def __init__(self, filepath: str = AUG_STRIKELINE_DATABASE,
                 species: str='Rb', createNew: bool = False):

        """
        Initializes the class and points it to a particular database for a
        certain species (you can combine several into one, but why would you?).
        The flag 'createNew' states whether a new file has to be created if
        it did not exist before.

        Pablo Oyola - pablo.oyola@ipp.mpg.de

        @param filepath: path to the database file.
        @param species: the name of the species to parse.
        @param createNew: if the file did not exist before, we create it. If
        it existed and it this is true, destroy the previou one. Default to
        False (i.e., not new files.)
        """
        self.filepath = filepath

        if (species.lower() != 'rb') and (species.lower() != 'cs'):
            raise Exception('Species non supported!')

        self.species = species
        # Opening the file to access the database.
        self.filename = filepath + species + '.nc4'

        if not os.path.isfile(self.filename):
            createNew = True

        # Opening the dataset.try:
        try:
            if createNew:
                self.root = nc4.Dataset(self.filename, mode='w')
            else:
                self.root = nc4.Dataset(self.filename, mode='a')
        except:
            raise Exception('File could not be opened')

        # Getting the number of elements in the database.
        if createNew:
            self.root.nstrikeline = 0

        self.nstrikeline = self.root.nstrikeline

    def __del__(self):
        """
        Closes the file.
        """

        self.root.close()

    def close(self):
        self.root.close()

    @property
    def size(self):
        """
        Gets the number of strikelines stored in the file.

        Pablo Oyola - pablo.oyola@ipp.mpg.de
        """

        # Update the data from the database.
        self.nstrikeline = self.root.nstrikeline

        # Return the actual number of strikelines.
        return self.nstrikeline

    def getProperty(self, name_list: str):
        """
        Retrieve a property from the strikeline list. The available variables
        are:
            x1(rhopol=1), x2(rhopol=1), avg(x1), avg(x2), E, beta, theta,
            q95, q0, bt0, ip, ne0, te0, nesep, tesep, kappa, Raus, Raxis,
            beamMass, beamIntensity, itotal, i_rate, shot_magn, diag_magn,
            exp_magn, ed_magn, shot_prof, diag_prof, exp_prof, ed_prof,
            timestamp, bcoils_flag, ripple_flag, bcoil_shot, bcoils_exp,
            bcoil_diag, bcoil_ed, electric_field_model, version


        Pablo Oyola - pablo.oyola@ipp.mpg.de

        @param name_list: iterable containing the strings to get from the
        file.
        """

        output = {}

        # A temporal matrix to store the data.
        tmp = np.zeros((self.size,))
        for ii in name_list:
            if ii not in self.fid.variables:
                print('Variable %s not found in the DB'%ii)
                continue
            for jj in self.size:
                name = 'strLine_%05d'%jj
                grp_hnd = self.fid.groups[name]

                tmp[jj] = grp_hnd.variables[ii][:].flatten()[0]

            output[ii] = tmp

        return output

    def check_strikeline_dictionary(self, strLine:dict, shotinfo: dict):
        """
        Checks whether the dictionary contains the minimal information to be
        written to the database.

        Pablo Oyola - pablo.oyola@ipp.mpg.de

        @param strLine: dictionary with the data of the strikeLine
        """

        # --- Definition of the minimal variables needed in the database.
        minimal_names = ['x1', 'x2', 'rhopol', 'w', 'timestamp', 'dx1', 'dx2']
        # --- Checking if the minimal data is stored in the strikeline dict.
        for ii in minimal_names:
            if ii not in strLine:
                print('%s property not found in map'%ii)
                return False

        # --- Checking the simulation run data.
        if 'rundata' not in strLine:
            print('rundata dictionary not inside map'%ii)
            return False

        minimal_names = ['version', 'fields', 'beam', 'magEQU', 'profiles',
                         'bcoils']

        for ii in minimal_names:
            if ii not in strLine['rundata']:
                print('%s property not found in rundata'%ii)
                return False


        # --- Checking the beam geometry.
        minimal_names = ['beta', 'theta', 'model', 'E', 'FWMH_E',
                         'divergency', 'mass', 'origin']

        for ii in minimal_names:
            if ii not in strLine['rundata']['beam']:
                print('%s property not found in beam data'%ii)
                return False

        # --- Checking the flags of the included fields.
        minimal_names = ['electric', 'bcoils', 'ripple_flag']
        for ii in minimal_names:
          if ii not in strLine['rundata']['fields']:
              print('%s property not found in fields flags'%ii)
              return False

        # --- Checking the data of the magnetic equilibrium:
        minimal_names = ['experiment', 'pulseNumber', 'diagnostic', 'edition']
        for ii in minimal_names:
          if ii not in strLine['rundata']['magEQU']:
              print('%s property not found in magnetic equilibrium'%ii)
              return False
          if ii not in strLine['rundata']['profiles']:
              print('%s property not found in profiles data'%ii)
              return False
          if strLine['rundata']['fields']['bcoils'] and \
             (ii not in strLine['rundata']['bcoils'][ii]):
              print('%s property not found in bcoil data'%ii)
              return False


        # --- Checking shot information.
        minimal_shot_data = ['q95', 'q0', 'ip', 'bt0', 'H1', 'H5', 'Rgeom',
                             'Raxis', 'Raus', 'beta_pol', 'elongation']

        for ii in minimal_shot_data:
            if (ii not in shotinfo):
                print('%s property not found in shotinfo'%ii)
                return False
        return True

    def write_new_strikeline(self, strLine: strikeLine):
        """
        Writes a new strikeline to the database. The input dictionary must
        contain at least the following:
            - Strikeline: x1(rhop), x2(rhop), w(rhop), beam energy and geometry
            - Magnetic equilibrium data (diag, exp, shot, edition)
            - Profiles data (diag, exp, shot, edition)
            - Shot basics
        Apart from these, also the following are available:
            -

        Pablo Oyola - pablo.oyola@ipp.mpg.de

        @param strLine: dictionary with all the data of the strikeline.
        """

        for ii in range(strLine.shape[0]):
            # Checking that the data is in the class:
            flag = self.check_strikeline_dictionary(strLine.maps[ii],
                                                    strLine.shotinfo)
            if not flag:
                warn('The strikeline %d in the class is not written to file'%\
                     ii)
                continue

            print(ii)

            # Getting the next id.
            strikeline_id = self.size + 1

            # Create a new strikeline ID as a group inside the netCDF file.
            newGrp = self.root.createGroup('%010d'%strikeline_id)

            #--- Writing the basic data to the file
            newGrp.createDimension('nbasis', size=len(strLine.maps[ii]['x1']))
            newGrp.createDimension('nchar_exp', size=8)
            newGrp.createDimension('nchar_diag', size=3)

            # Basis of the mapping.
            newVar = newGrp.createVariable('rhopol', 'f8',
                                         dimensions=('nbasis',))
            newVar[:] = strLine.maps[ii]['rhopol']
            newVar.short_name = '$\\rho_{pol}$'
            newVar.units = ''
            newVar.long_name = 'Birth position/Mapping variable'

            # x1.
            newVar = newGrp.createVariable('x1', 'f8',
                                         dimensions=('nbasis',))
            newVar[:] = strLine.maps[ii]['x1']*100.0
            newVar.short_name = '$X_{scintillator}$'
            newVar.units = 'cm'
            newVar.long_name = 'Coordinate of strikeline along the horizontal\
                         (shortest) direction'

            # x2.
            newVar = newGrp.createVariable('x2', 'f8',
                                         dimensions=('nbasis',))
            newVar[:] = strLine.maps[ii]['x2']*100.0
            newVar.short_name = '$Y_{scintillator}$'
            newVar.units = 'cm'
            newVar.long_name = 'Coordinate of strikeline along the vertical\
                         (longest) direction'

            # dx1.
            newVar = newGrp.createVariable('dx1', 'f8',
                                         dimensions=('nbasis',))
            newVar[:] = strLine.maps[ii]['dx1']*100.0
            newVar.short_name = '$\\Delta x$'
            newVar.units = 'cm'
            newVar.long_name = 'Uncertainty coordinate of strikeline along the \
                          horizontal (shortest) direction'

            # dx2.
            newVar = newGrp.createVariable('dx2', 'f8',
                                         dimensions=('nbasis',))
            newVar[:] = strLine.maps[ii]['dx2']*100.0
            newVar.short_name = '$\\Delta y$'
            newVar.units = 'cm'
            newVar.long_name = 'Uncertainty coordinate of strikeline along the \
                          vertical (longest) direction'

            # w.
            newVar = newGrp.createVariable('w', 'f8',
                                         dimensions=('nbasis',))
            newVar[:] = strLine.maps[ii]['w']
            newVar.short_name = '$\\phi_{ion}$'
            newVar.units = 'ion/s'
            newVar.long_name = 'Ion flux per unit area into the scintillator'

            # Timepoint
            newVar = newGrp.createVariable('timestamp', 'f8',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['timestamp']
            newVar.short_name = '$t_0$'
            newVar.units = 's'
            newVar.long_name = 'Time stamp for the strikeline'

            #--- Version
            newVar = newGrp.createVariable('version_major', 'i4',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['version'][0]
            newVar.short_name = 'Version Major'
            newVar.units = ''
            newVar.long_name = 'Version Major'

            newVar = newGrp.createVariable('version_minor', 'i4',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['version'][1]
            newVar.short_name = 'Version Minor'
            newVar.units = ''
            newVar.long_name = 'Version Minor'

            newVar = newGrp.createVariable('version_fixes', 'i4',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['version'][2]
            newVar.short_name = 'Version Fixes'
            newVar.units = ''
            newVar.long_name = 'Version Fixes'

            #--- Beam geometry
            newVar = newGrp.createVariable('beta', 'f8',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['beam']['beta']
            newVar.short_name = '$\\beta_{tilting}$'
            newVar.units = 'rad'
            newVar.long_name = 'Toroidal tilting angle of the beam'

            newVar = newGrp.createVariable('theta', 'f8',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['beam']['theta']
            newVar.short_name = '$\\Theta_{tilting}$'
            newVar.units = 'rad'
            newVar.long_name = 'Poloidal tilting angle of the beam'

            newVar = newGrp.createVariable('model', 'i4',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['beam']['model']
            newVar.short_name = 'Injection model'
            newVar.units = ''
            newVar.long_name = 'Injection model.\n\
                           0: beam-line, no diverg. no E spread\n\
                           1: finite beam, no diverg. w/ E spread\n\
                           2: finite beam, w/ divergency and E-spread'

            newVar = newGrp.createVariable('E', 'f8',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['beam']['E']
            newVar.short_name = '$E$'
            newVar.units = 'keV'
            newVar.long_name = 'Central beam energy'

            newVar = newGrp.createVariable('FWMH_E', 'f8',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['beam']['FWMH_E']
            newVar.short_name = '$FWMH_E$'
            newVar.units = 'keV'
            newVar.long_name = 'Full width half maximum of the energy Gaussian'

            newVar = newGrp.createVariable('divergency', 'f8',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['beam']['divergency']
            newVar.short_name = '$\\alpha_{beam}$'
            newVar.units = '${}^{o}$'
            newVar.long_name = 'Opening angle of the beam - Divergence of the beam'

            newVar = newGrp.createVariable('beammass', 'f8',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['beam']['mass']
            newVar.short_name = '$M_{beam}$'
            newVar.units = 'AMU'
            newVar.long_name = 'Ion mass of the beam in Atomic Mass Units'

            newVar = newGrp.createVariable('origin_X', 'f8',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['beam']['origin'][0]
            newVar.short_name = '$X_{origin}$'
            newVar.units = 'm'
            newVar.long_name = 'Cartesian X-like position of the beam injection'

            newVar = newGrp.createVariable('origin_Y', 'f8',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['beam']['origin'][1]
            newVar.short_name = '$Y_{origin}$'
            newVar.units = 'm'
            newVar.long_name = 'Cartesian Y-like position of the beam injection'

            newVar = newGrp.createVariable('origin_Z', 'f8',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['beam']['origin'][2]
            newVar.short_name = '$Z_{origin}$'
            newVar.units = 'm'
            newVar.long_name = 'Cartesian Z-like position of the beam injection'

            #--- Simulations flags.
            newVar = newGrp.createVariable('electricflag', 'u1',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['fields']['electric']
            newVar.short_name = 'Electric field flag'
            newVar = newGrp.createVariable('bcoilsflag', 'u1',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['fields']['bcoils']
            newVar.short_name = 'B-coils field flag'

            newVar = newGrp.createVariable('ripple_flag', 'u1',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['fields']['ripple_flag']
            newVar.short_name = 'Ripple field flag'

            #--- Shot data for the magnetics.
            newVar = newGrp.createVariable('shot_magn', 'i4',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['magEQU']['pulseNumber']
            newVar.short_name = 'Shotnumber of the magnetic reconstruction'


            newVar = newGrp.createVariable('exp_magn', 'S1',
                                           dimensions=('nchar_exp',))

            chain = np.array([strLine.maps[ii]['rundata']\
                              ['magEQU']['experiment'].ljust(8, ' ')], 'S')

            newVar[:] = nc4.stringtochar(chain)
            newVar.short_name = 'Experiment of the magnetic reconstruction'

            newVar = newGrp.createVariable('diag_magn', 'S1',
                                           dimensions=('nchar_diag',))
            chain = np.array([strLine.maps[ii]['rundata']\
                              ['magEQU']['diagnostic']], 'S')
            newVar[:] = nc4.stringtochar(chain)
            newVar.short_name = 'Diagnostic of the magnetic reconstruction'


            newVar = newGrp.createVariable('ed_magn', 'i4',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['magEQU']['edition']
            newVar.short_name = 'Edition of the magnetic reconstruction'


            #--- Shot data for the profiles.
            newVar = newGrp.createVariable('shot_prof', 'i4',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['profiles']['pulseNumber']
            newVar.short_name = 'Shotnumber of the profiles'


            newVar = newGrp.createVariable('exp_prof', 'S1',
                                           dimensions=('nchar_exp',))
            chain = np.array([strLine.maps[ii]['rundata']\
                              ['profiles']['experiment'].ljust(8, ' ')], 'S')

            newVar[:] = nc4.stringtochar(chain)
            newVar.short_name = 'Experiment of the magnetic reconstruction'

            newVar = newGrp.createVariable('diag_prof', 'S1',
                                           dimensions=('nchar_diag',))
            chain = np.array([strLine.maps[ii]['rundata']\
                              ['profiles']['diagnostic']], 'S')

            newVar[:] = nc4.stringtochar(chain)
            newVar.short_name = 'Diagnostic of the magnetic reconstruction'


            newVar = newGrp.createVariable('ed_prof', 'i4',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['profiles']['edition']
            newVar.short_name = 'Edition of the profiles'

            #--- Shot data for the B-coils.
            newVar = newGrp.createVariable('shot_bcoils', 'i4',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['bcoils']['pulseNumber']
            newVar.short_name = 'Shotnumber of the B-coils data'

            newVar = newGrp.createVariable('exp_bcoils', 'S1',
                                           dimensions=('nchar_exp',))
            chain = np.array([strLine.maps[ii]['rundata']\
                              ['bcoils']['experiment'].ljust(8, ' ')], 'S')

            newVar[:] = nc4.stringtochar(chain)
            newVar.short_name = 'Experiment of the magnetic reconstruction'

            newVar = newGrp.createVariable('diag_bcoils', 'S1',
                                           dimensions=('nchar_diag',))
            chain = np.array([strLine.maps[ii]['rundata']\
                              ['bcoils']['diagnostic']], 'S')

            newVar[:] = nc4.stringtochar(chain)
            newVar.short_name = 'Diagnostic of the magnetic reconstruction'

            newVar = newGrp.createVariable('ed_bcoils', 'i4',
                                           dimensions=())
            newVar[:] = strLine.maps[ii]['rundata']['bcoils']['edition']
            newVar.short_name = 'Edition of the B-coils data'

            # --- Writing shot data from the AUG database.
            newVar = newGrp.createVariable('q95', 'f8',
                                           dimensions=())
            newVar[:] = strLine.shotinfo['q95'][ii]
            newVar.short_name = '$q_{95}$'
            newVar.units = ''
            newVar.long_name = 'q-profile evaluated at rhopol = 0.95'

            newVar = newGrp.createVariable('q0', 'f8',
                                           dimensions=())
            newVar[:] = strLine.shotinfo['q0'][ii]
            newVar.short_name = '$q_{0}$'
            newVar.units = ''
            newVar.long_name = 'q-profile evaluated on the magnetic axis'

            newVar = newGrp.createVariable('Ip', 'f8',
                                           dimensions=())
            newVar[:] = strLine.shotinfo['ip'][ii]
            newVar.short_name = '$I_p$'
            newVar.units = 'MA'
            newVar.long_name = 'Plasma current'

            newVar = newGrp.createVariable('Bt0', 'f8',
                                           dimensions=())
            newVar[:] = strLine.shotinfo['bt0'][ii]
            newVar.short_name = '$B_t^{0}$'
            newVar.units = ''
            newVar.long_name = 'Magnetic field at the geometric axis'

            newVar = newGrp.createVariable('Raus',  'f8',
                                           dimensions=())
            newVar[:] = strLine.shotinfo['Raus'][ii]
            newVar.short_name = '$R_{aus}$'
            newVar.units = ''
            newVar.long_name = 'Major radius of the separatrix at the LFS z=0'

            newVar = newGrp.createVariable('Rgeom', 'f8',
                                           dimensions=())
            newVar[:] = strLine.shotinfo['Rgeom'][ii]
            newVar.short_name = '$R_{geom}$'
            newVar.units = ''
            newVar.long_name = 'Major radius of the geometric axis'

            newVar = newGrp.createVariable('Raxis', 'f8',
                                           dimensions=())
            newVar[:] = strLine.shotinfo['Raxis'][ii]
            newVar.short_name = '$R_{mag}$'
            newVar.units = ''
            newVar.long_name = 'Major radius of the magnetic axis'

            newVar = newGrp.createVariable('H1', 'f8',
                                           dimensions=())
            newVar[:] = strLine.shotinfo['H1'][ii]
            newVar.short_name = '$H1$'
            newVar.units = '$m^{-3}$'
            newVar.long_name = 'Core-line of the DCN system'

            newVar = newGrp.createVariable('H5', 'f8',
                                           dimensions=())
            newVar[:] = strLine.shotinfo['H5'][ii]
            newVar.short_name = '$H5$'
            newVar.units = '$m^{-3}$'
            newVar.long_name = 'Edge-line of the DCN system'

            newVar = newGrp.createVariable('betapol', 'f8',
                                           dimensions=())
            newVar[:] = strLine.shotinfo['beta_pol'][ii]
            newVar.short_name = '$\\beta_{pol}$'
            newVar.units = ''
            newVar.long_name = 'Poloidal beta of the plasma'

            newVar = newGrp.createVariable('elongation', 'f8',
                                           dimensions=())
            newVar[:] = strLine.shotinfo['elongation'][ii]
            newVar.short_name = '$\\kappa$'
            newVar.units = ''
            newVar.long_name = 'Plasma elongation'

            for jj in [0.0, 0.5, 0.8, 0.9, 0.95, 1.0]:
                name = 'ne%d'%int(jj*100)

                newVar = newGrp.createVariable(name, 'f8',
                                           dimensions=())
                newVar[:] = strLine.shotinfo[name][ii]
                newVar.short_name = '$n_e$ (@ $\\rho_{pol} = %.2f)$'%jj
                newVar.units = '$m^{-3}$'
                newVar.long_name = 'Electron density (IDA) at rhopol=%.2f'%jj

                name = 'Te%d'%int(jj*100)

                newVar = newGrp.createVariable(name, 'f8',
                                           dimensions=())
                newVar[:] = strLine.shotinfo[name][ii]
                newVar.short_name = '$T_e$ (@ $\\rho_{pol} = %.2f)$'%jj
                newVar.units = '$keV$'
                newVar.long_name = 'Electron temperature (IDA) at rhopol=%.2f'%jj

            self.root.nstrikeline += 1
