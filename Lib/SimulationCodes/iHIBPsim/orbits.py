"""
iHIBPsim orbit library

This library provided an easy API to access and work with the data in the orbits
files generated by the iHIBPsim code.

The orbit files is a binary file containing first a header that establish how
many particles are going to be recorded, size and which properties are saved
to the file, plus some extra metadata, so the library can be quasi-agnostic
on which kind of orbit is simulated.
"""

import numpy as np
import numba as nb
import os
import sys
import matplotlib.pyplot as plt
import xarray as xr
import logging

logger = logging.getLogger('iHIBPsim.orbits')

def readHeader(fn: str) -> dict:
    """
    Read the header of the orbit file.

    Pablo Oyola - poyola@us.es

    :param fn: Filename to read the header.
    """

    with open(fn, 'rb') as fid:
        # Reading the basic header.
        name = b''.join(np.fromfile(fid, 'byte', 12)).decode().strip().lower()
        if(name != 'ihibpsim'):
            raise ValueError('The header is badly formatted!')

        version = np.fromfile(fid, 'int32', 3)
        nch     = np.fromfile(fid, 'int32', 1)[0]
        max_steps = np.fromfile(fid, 'int32', 1)[0]

        for ich in range(nch):
            tmp = np.fromfile(fid, 'int32', 5)
            idx = tmp[0]
            index_real = tmp[1]
            lens = tmp[2:]
            if ich == 0:
                props = { 'name': np.zeros((nch, ), dtype=object),
                          'unit': np.zeros((nch, ), dtype=object),
                          'desc': np.zeros((nch, ), dtype=object),
                          'idx_real': np.zeros((nch, ), dtype=int),
                          'idx_new': np.zeros((nch, ), dtype=int),
                        }
            # Filling the property list:
            props['idx_real'][ich] = index_real
            props['idx_new'][ich]  = idx
            props['name'][ich] = b''.join(np.fromfile(fid, 'byte', lens[0])).decode().strip()
            props['unit'][ich] = b''.join(np.fromfile(fid, 'byte', lens[1])).decode().strip()
            props['desc'][ich] = b''.join(np.fromfile(fid, 'byte', lens[2])).decode().strip()
        props['header_shift'] = fid.tell()
        props['nch'] = nch
        props['version'] = version
        props['max_steps'] = max_steps
    return props

def parse_orbit_file(fn: str, hdr: dict):
    """
    Parse the full file for the orbits sizes and positions.

    Pablo Oyola - poyola@us.es

    :param fn: filename.
    :param hdr: header of the file already read.
    """
    #Preallocating some data.
    id_list = list()
    nstep_list = list()
    shift_list = list()


    with open(fn, 'rb') as fid:
        fid.seek(-1, 2) # Go to the end.
        file_size = fid.tell() # This is the file size.

        fid.seek(hdr['header_shift'], 0) # Return to the first orbit place.

        while fid.tell() <= file_size:
            orbit_idx, nsteps = np.fromfile(fid,
                                            'float64',
                                            2).astype(dtype=int).tolist()
            size = hdr['nch'] * nsteps
            shift = fid.tell()
            fid.seek(size*8, 1)

            id_list.append(orbit_idx)
            nstep_list.append(nsteps)
            shift_list.append(shift)

        id_list = np.array(id_list)
        nstep_list = np.array(nstep_list)
        shift_list = np.array(shift_list)
        return id_list, nstep_list, shift_list

class orbit:
    """
    Object containing a single orbit data with routines allowing handling the
    data.

    Pablo Oyola - poyola@us.es
    """
    def __init__(self, data: float,  names: str, idx: int=None,
                 desc: str=None, units:str=None):
        """
        This will store the data into a Xarray using the inputs names.

        Pablo Oyola - poyola@us.es

        :param data: data array with the shape (nstep, nCharacteristics)
        :param names: names of each characteristics.
        :param desc: description of each characteristic. Optional.
        :param units: units of each characteristic. Optional.
        :param idx: list of indices of the names. If not provided, the
        name of the characteristics are supposed to be ordered.
        """
        # Working out the inputs.
        if isinstance(names, str):
            names = (names,)

        data = np.atleast_2d(data)
        idx  = np.atleast_1d(idx)

        # Checking size consistency of the inputs.
        nch = len(names)
        if nch != data.shape[1]:
            raise ValueError('The data and the number of names do not match!\n'+
                             '%d /= %d'%(data.shape[1], nch))

        # If not provided, then we just generated them orderly.
        if idx is None:
            idx = np.arange(nch)

        if nch != idx.size:
            raise ValueError('The indices and the number of names do not '+
                             'match!\n %d /= %d'%(data.shape[1], nch))

        if desc is not None:
            if isinstance(desc, str):
                desc = (desc,)
            if len(desc) != nch:
                raise ValueError('The descriptions and the number of names '+
                                 ' do not match!\n %d /= %d'%(len(desc),
                                                              nch))
        if units is not None:
            if isinstance(units, str):
                units = (units,)
            if len(units) != nch:
                raise ValueError('The units and the number of names '+
                                 ' do not match!\n %d /= %d'%(len(units),
                                                              nch))
        # We now generate the dataset.
        self.data = xr.Dataset()

        # Loop over the characteristics.
        for ii, ich in enumerate(idx):
            attrs = { }
            if units is not None:
                attrs['units'] = units[ii]
            if desc is not None:
                attrs['desc'] = desc[ii]

            self.data[names[ii]] = xr.DataArray(data[:, ich - 1],
                                                dims='time',
                                                attrs=attrs)

        # Some post-process
        # 1. If the data is found in cylindrical coordinates, add transformation
        #    to Cartesian.
        def Rphi2x(R: float, phi: float):
            return R*np.cos(phi)
        def Rphi2y(R: float, phi: float):
            return R*np.sin(phi)

        try:
            self.new_var('x', Rphi2x, dependencies=('R', 'phi'), units='m',
                         desc='Cartesian X coordinate')
            self.new_var('y', Rphi2y, dependencies=('R', 'phi'), units='m',
                         desc='Cartesian Y coordinate')
        except:
            logger.warning('Cannot add the Cartesian variables.')

    def new_var(self, name: str, func: callable, dependencies: str=None,
                units: str=None, desc: str=None):
        """
        Creates a new variable starting from the existing ones and adds it
        to the list.

        Pablo Oyola - poyola@us.es

        :param name: name of the variable. Must be different from the existing.
        :param dependencies: name of the variables on which the new variable
        depend. If None, it is fully independent.
        :param units: units of the new variable. Optional.
        :param desc: description of the new variable. Optional,
        """
        if name in self.data:
            raise NameError('The variable %s is already in the dataset'%name)

        # Checking dependencies:
        if dependencies is not None:
            if isinstance(dependencies, str):
                dependencies = (dependencies,)

            if np.any([ii not in self.data for ii in dependencies]):
                raise ValueError('There are unmatched dependencies!')

            deps = {ii: self.data[ii] for ii in dependencies}
        else:
            deps = dict()

        # Getting the new variable.
        tmp = func(**deps)

        # Generating the attributes.
        attrs = {}
        if units is not None:
            attrs['units'] = units
        if desc is not None:
            attrs['desc'] = desc

        self.data[name] = xr.DataArray(tmp, dims='time', attrs=attrs)

    def view(self, view: str='pol', ax=None, plot_start_end: bool = False,
             **plt_params):
        """
        Plot the orbit either in 2D (poloidal or toroidal projections) or in 3D.

        Pablo Oyola - poyola@us.es

        :param view: projection or view of the orbit. Either pol, tor or 3D.
        Case insensitive.
        :param ax: axis to plot the orbit. New ones will be created accordingly.
        :param plot_start_end: whether to plot the starting and ending points.
        False by default.
        """
        if view not in ('pol', 'tor', '3d'):
            raise ValueError('The view cannot be recognized!')

        # Creating the new axes if none are provied.
        ax_was_none = ax is None
        if ax_was_none:
            if view.lower() == '3d':
                fig = plt.figure()
                ax  = fig.add_subplot(111, projection='3d')
            else:
                fig, ax = plt.subplots(1)

        if view.lower() == 'pol':
            line = self.plot('R', 'z', ax=ax, plot_start_end=plot_start_end,
                             **plt_params)
        elif view.lower() == 'tor':
            line = self.plot('x', 'y', ax=ax, plot_start_end=plot_start_end,
                             **plt_params)
        else:
            x = self.data.x.values
            y = self.data.y.values
            z = self.data.z.values
            line = ax.plot(x, y, z, **plt_params)

            if plot_start_end:
                ax.plot(x[0], y[0], z[0], 'go')
                ax.plot(x[-1], y[-1], z[-1], 'ro')

        if ax_was_none:
            pass

        return line, ax

    def plot(self, *args, ax=None, plot_start_end: bool=False, **plt_params):
        """
        Generic plotting routine.

        Pablo Oyola - poyola@us.es

        :param args: a list of 1, 2 or 3 elements to be plotted:
            - len(args)=1 -> variable vs. time is plotted.
            - len(args)=2 -> x = args[0] & y = args[1]
            - len(args)=3 -> x = args[0] & y = args[1] & z = args[2]
        :param ax: axis to plot. New ones are created if not provided.
        :param plot_start_end: marks the start and the end of the array with
        two distint-coloured markers.
        :param plt_params: extra keyword arguments to send down to plot routine.
        """
        if(len(args) > 3):
            raise ValueError('The number of plottable arguments is 3 '+
                             '(can you see in 4D??!!)')

        # Checking all elements are in the Dataset.
        if np.any([ii not in self.data for ii in args]):
            raise ValueError('Some input variables are not found in the data!')

        # Checking the axes.
        ax_was_none = ax is None
        if ax_was_none:
            if len(args) == 3:
                fig = plt.figure()
                ax  = fig.add_subplot(111, projection='3d')
            else:
                fig, ax = plt.subplots(1)

        if len(args) == 1:
            time = self.data['time'].values
            x    = self.data[args[0]].values
            line = ax.plot(time, x, **plt_params)

            if plot_start_end:
                ax.plot(time[0], x[0], 'go')
                ax.plot(time[-1], x[-1], 'ro')

            xlabel = 'Time'
            if 'units' in self.data.time.attrs:
                xlabel += ' [%s]' % self.data.time.units

            ylabel = '%s'%args[0]
            if 'units' in self.data[args[0]].attrs:
                ylabel += ' [%s]' % self.data[args[0]].units

        elif len(args) == 2:
            x = self.data[args[0]].values
            y = self.data[args[1]].values
            line = ax.plot(x, y, **plt_params)

            if plot_start_end:
                ax.plot(x[0], y[0], 'go')
                ax.plot(x[-1], y[-1], 'ro')

            xlabel = '%s'%args[0]
            if 'units' in self.data[args[0]].attrs:
                xlabel += ' [%s]' % self.data[args[0]].units

            ylabel = '%s'%args[1]
            if 'units' in self.data[args[1]].attrs:
                ylabel += ' [%s]' % self.data[args[1]].units
        else:
            x = self.data[args[0]].values
            y = self.data[args[1]].values
            z = self.data[args[2]].values
            line = ax.plot(x, y, z, **plt_params)

            if plot_start_end:
                ax.plot(x[0], y[0], z[0], 'go')
                ax.plot(x[-1], y[-1], z[-1], 'ro')

            xlabel = '%s'%args[0]
            if 'units' in self.data[args[0]].attrs:
                xlabel += ' [%s]' % self.data[args[0]].units

            ylabel = '%s'%args[1]
            if 'units' in self.data[args[1]].attrs:
                ylabel += ' [%s]' % self.data[args[1]].units

            zlabel = '%s'%args[2]
            if 'units' in self.data[args[2]].attrs:
                zlabel += ' [%s]' % self.data[args[2]].units

        if ax_was_none:
            ax.set_xlabel(xlabel)
            ax.set_ylabel(ylabel)
            if len(args) == 3:
                ax.set_zlabel(zlabel)


        return ax, line
class orbitFile:
    """
    A class handling an orbit file generated by the iHIBPsim code.

    Pablo Oyola - poyola@us.es
    """
    def __init__(self, filename: str):
        """
        Initializes the class by providing the file where the orbits are
        stored.

        Pablo Oyola - poyola@us.es

        :param filename: filename with the orbits data.
        """
        if not os.path.isfile(filename):
            raise FileNotFoundError('Cannot find the orbits file: %s'%filename)

        # Reading the header.
        self.fn = filename
        self.header = readHeader(filename)
        self.ids, self.nsteps, self.shifts = parse_orbit_file(self.fn,
                                                              self.header)

        # Checking if there are repeated elements.
        if np.unique(self.ids).size != self.ids.size:
            logger.warning('There are repeated IDs!')
            self.ids = np.arange(len(self.ids))
        # We will sort the IDs in increasing order.
        sortidx = np.argsort(self.ids)
        self.ids = self.ids[sortidx]
        self.nsteps = self.nsteps[sortidx]
        self.shifts = self.shifts[sortidx]

    def __get_orbit(self, ids: int):
        """
        Read the orbit(s) indicated by the corresponding ID(s). Internal
        routine not to be directly used.

        Pablo Oyola - poyola@us.es

        :param ids: ID(s) of the file.
        """
        # Transforming the IDs into a numpy array.
        ids = np.atleast_1d(ids)

        # Checking that all IDs do exist.
        if np.any([ii not in self.ids for ii in ids]):
            raise ValueError('Some of the IDs do not exist in the file!')

        orbs = dict()
        with open(self.fn, 'rb') as fid:
            for ii in range(len(ids)):
                idx = np.where(ids[ii] == ids)[0][0]
                orbitsize = self.nsteps[idx] * self.header['nch']

                # Going to the beginning of the orbit.
                fid.seek(self.shifts[idx], 0)
                data = np.fromfile(fid, 'float64', orbitsize)
                data = np.reshape(data, (self.header['nch'], self.nsteps[idx]),
                                  order='F').T

                # We generate a orbit object.
                orbs[ids[ii]] = orbit(data, names=self.header['name'],
                                      units=self.header['unit'],
                                      desc=self.header['desc'],
                                      idx=self.header['idx_new'])

        if len(ids) == 1:
            orbs = orbs[ids[ii]]

        return orbs


    def generator(self, idList: int=None, internal_buffer: float=1.0):
        """
        Creates a generator that will consecutively reads the orbits.

        Pablo Oyola - poyola@us.es

        :param idList: provides a list of orbits to be returned. If None, the
        orbits will be returned in ascending order of ID.
        :param internal_buffer: limit of the generator buffer. This is useful
        to load many orbits and avoid the delay of disk access. Also useful
        to avoid overloading the RAM when heavy orbit files are loaded.
        """
        # Checking the input orbit list.
        if idList is None:
            idList = self.ids.copy() # Making a deep copy.

        # Transforming the input ID list into a numpy array.
        idList = np.atleast_1d(idList)

        idx_tot    = len(idList)
        idx_now    = 0
        idx_max    = 0
        idx_abs    = 0
        finished   = False
        buffer     = None

        # We precompute the orbit sizes.
        orbs_sizes = np.zeros((len(idList)), dtype=int)
        for iorb in range(len(idList)):
            try:
                ii = np.where(idList[iorb] == self.ids)[0][0]
            except:
                raise ValueError('The orbit #%d is not in the file'%idList[iorb])

            orbs_sizes[iorb] = self.header['nch'] * self.nsteps[ii] * 8



        while (not finished):
            # Reading part.
            if idx_now == idx_max:
                idx_now = 0
                idx_max = 0
                tot = 0.0

                # We need to keep reading the orbits, but keeping the
                # max. buffer limitation.
                while tot < internal_buffer:
                    tot = orbs_sizes[idx_abs + idx_max]
                    idx_max += 1
                    if(idx_abs + idx_max == idx_tot):
                        break

                buffer = self[np.arange(idx_abs+1, idx_abs + idx_max + 1)]

            # We are done reading the orbits, return the current one.
            if isinstance(buffer, orbit):
                yield buffer
            else:
                yield buffer[idx_now]

            idx_now += 1
            idx_abs += 1
            if idx_abs == idx_tot:
                finished = True

    def __getitem__(self, ids):
        """
        Wrapper for the [...] object allowing the user a simpler retrieval of
        the orbits.

        Pablo Oyola - poyola@us.es

        :param ids: ID of the file.
        """
        if isinstance(ids, slice):
            ids = np.mgrid[ids]

        return self.__get_orbit(ids)

    def __call__(self):
        """
        Wrapper to call the orbits generator.
        """

        return self.generator()

    @property
    def size(self):
        """
        Number of orbits in the file.
        """
        return len(self.ids)

    @property
    def shape(self):
        """
        Orbits shape: number of characteristics, number of orbits.
        """

        return self.header['nch'], self.size