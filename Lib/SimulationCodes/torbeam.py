"""
ECRH TORBEAM.

Pablo Oyola - pablo.oyola@ipp.mpg.de
"""

import os

import numpy as np
import matplotlib.pyplot as plt
from copy import deepcopy

from Lib.LibData.AUG.DiagParam import num_of_gyrotrons
from Lib.ufiles import ufile
import Lib.errors as errors

_AVAILABLE_GYROTRONS = np.arange(num_of_gyrotrons) + 1


def load_Ufile(path: str):
    """
    Loads and prepare the U-file from the TORBEAM simulations and returns a
    dictionary.

    Pablo Oyola - pablo.oyola@ipp.mpg.de

    @param path: path to the file to be read.
    """
    data = ufile(path)

    output = { 'rhopol': data.Y['data'].squeeze(),
               'data':   data.f['data'].squeeze(),
               'unit':   data.f['unit']
             }
    return output



class torbeam:
    """
    This class handles the u-files generated by the TB-gui and works as an
    API for those.

    Pablo Oyola - pablo.oyola@ipp.mpg.de
    """
    def __init__(self, path: str, shotnumber: int):
        """
        Loads the file(s) corresponding to the TORBEAM simulation by providing
        the path where all the files are stored:
            - ECRHXXXXX.gyY.tb.rpol  -> Power deposition.
            - ECCDXXXXX.gyY.tb.rpol  -> ECCD deposition .
            - EXXXXX.PED.tb.rpol      -> Electron temperature.
            - NXXXXX.PED.tb.rpol      -> Electron density.
            - VOLXXXXX.VOL.tb.rpol    -> Volume per rhopol.

        where XXXXX -> shotnumber and Y -> gyrotron.
        """
        if not os.path.isdir(path):
            raise FileNotFoundError('Cannot find the path')

        ## Allocating space for the internal variables.
        self.eccd = dict()
        self.ecrh = dict()
        self.gyr_avails = list()

        # Looping over all the gyrotrons.
        for ii in _AVAILABLE_GYROTRONS:
            fn    = 'ECCD%05d.gy%d.tb.rpol'%(shotnumber, ii)
            path0 = os.path.join(path, fn)

            if not os.path.isfile(path0):
                continue
            self.eccd[ii] = load_Ufile(path0)

            # Looking for the maximum position of the ECCD deposition.
            idx = np.abs(self.eccd[ii]['data']).argmax()
            self.eccd[ii]['rhopol_max'] = self.eccd[ii]['rhopol'][idx]
            self.eccd[ii]['eccd_max']   = self.eccd[ii]['data'][idx]

            fn    = 'ECRH%05d.gy%d.tb.rpol'%(shotnumber, ii)
            path0 = os.path.join(path, fn)
            self.ecrh[ii] = load_Ufile(path0)

            # Looking for the maximum position of the ECRH deposition.
            idx = self.ecrh[ii]['data'].argmax()
            self.ecrh[ii]['rhopol_max'] = self.ecrh[ii]['rhopol'][idx]
            self.ecrh[ii]['ecrh_max']   = self.ecrh[ii]['data'][idx]

            self.gyr_avails.append(ii)


        self.gyr_avails = np.array(self.gyr_avails)

        ## Loading the density, temperature and volume.
        fn = 'N%05d.PED.tb.rpol'%(shotnumber)
        path0 = os.path.join(path, fn)
        self.density = load_Ufile(path0)

        fn = 'E%05d.PED.tb.rpol'%(shotnumber)
        path0 = os.path.join(path, fn)
        self.temperature = load_Ufile(path0)

        fn = 'VOL%05d.VOL.tb.rpol'%(shotnumber)
        path0 = os.path.join(path, fn)
        self.volume = load_Ufile(path0)

    def plotMaximum(self, what: str='ECCD', gyr: int=None, ax=None,
                    cmap=None, **kwargs):
        """
        Plots the trend of the maximum of the deposition weighting the color
        with a colorbar.

        Pablo Oyola - pablo.oyola@ipp.mpg.de

        @param what: what to plot, either 'eccd' or 'ecrh' (case insensitive).
        @param gyr: gyrotron(s) to plot.
        @param ax: axis to plot. If None, new ones will be created.
        @param kwargs: plotting keyword arguments.
        """
        if gyr is None:
            gyr = deepcopy(self.gyr_avails)
        gyr = np.atleast_1d(gyr)

        ## Check which option is chosen by the user to plot.
        if what.lower() == 'eccd':
            data = self.eccd
        elif what.lower() == 'ecrh':
            data = self.ecrh
        else:
            raise errors.NotValidInput('Only ECCD or ECHR are valid inputs')

        ## Available gyrotrons
        flags = [(igyr not in self.gyr_avails) for igyr in gyr]
        if np.any(flags):
            raise errors.NotValidInput('Gyrotrons '+str(gyr[flags]) + \
                                       ' not available in the machine.')


        ## Opening the plot.
        # ax_was_none = ax is None
        # if ax_was_none:
        #     fig, ax = plt.subplots(1)

        ## Plotting the data.

        return

    def plot(self, what: str='ECCD', gyr: int=None, ax=None,
             volume:bool=False, **kwargs):
        """"
        Plots either the ECRH or the ECCD signal for the input gyrotron(s).

        Pablo Oyola - pablo.oyola@ipp.mpg.de

        @param what: what to plot, either 'eccd' or 'ecrh' (case insensitive).
        @param gyr: gyrotron(s) to plot.
        @param ax: axis to plot. If None, new ones will be created.
        @param kwargs: plotting keyword arguments.
        """
        if gyr is None:
            gyr = deepcopy(self.gyr_avails)
        gyr = np.atleast_1d(gyr)

        ## Check which option is chosen by the user to plot.
        if what.lower() == 'eccd':
            data = self.eccd.copy()
        elif what.lower() == 'ecrh':
            data = self.ecrh.copy()
        else:
            raise errors.NotValidInput('Only ECCD or ECHR are valid inputs')


        ## Available gyrotrons
        flags = [(igyr not in self.gyr_avails) for igyr in gyr]
        if np.any(flags):
            raise errors.NotValidInput('Gyrotrons '+str(gyr[flags]) + \
                                       ' not available in the machine.')


        ## Opening the plot.
        ax_was_none = ax is None
        if ax_was_none:
            fig, ax = plt.subplots(1)
        if 'label' not in kwargs:
            label_set = False
        else:
            label_set = True

        ## Plotting.
        for ii in gyr:
            if not label_set:
                kwargs['label'] = 'Gyr. %d'%ii

            if volume:
                dataplot = data[ii]['data'] * self.volume['data']
            else:
                dataplot = data[ii]['data']
            ax.plot(data[ii]['rhopol'], dataplot, **kwargs)

        if ax_was_none:
            ax.set_xlabel('$\\rho_{pol}$')

            ikey0 = self.gyr_avails[0]
            ax.set_ylabel(what.upper() + ' ($%s$)'%data[ikey0]['unit'])
            ax.grid('both')
            ax.legend()

        return ax

    @property
    def maxECRH(self):
        """
        Returns the location of the maximum deposition in the ECRH.
        """
        return [self.ecrh[igyr]['rhopol_max'] for igyr in self.gyr_avails]

    @property
    def maxECCD(self):
        """
        Returns the location of the maximum deposition in the ECRH.
        """
        return [self.eccd[igyr]['rhopol_max'] for igyr in self.gyr_avails]

    @property
    def maxECRHval(self):
        """
        Returns the value of the maximum deposition in the ECRH.
        """
        return [self.ecrh[igyr]['ecrh_max'] for igyr in self.gyr_avails]

    @property
    def maxECCDval(self):
        """
        Returns the value of the maximum deposition in the ECRH.
        """
        return [self.eccd[igyr]['eccd_max'] for igyr in self.gyr_avails]